package mathsets.algebra

/**
 * An element of the dihedral group D_n, represented as a rotation optionally
 * followed by a reflection.
 *
 * @property rotation The rotation index in `{0, ..., n-1}`, representing a rotation
 *           by `rotation * (2pi/n)` radians.
 * @property reflected Whether this element includes a reflection.
 */
data class DihedralElement(val rotation: Int, val reflected: Boolean) {
    override fun toString(): String = if (reflected) "sr^$rotation" else "r^$rotation"
}

/**
 * The dihedral group D_n: the group of symmetries of a regular n-gon.
 *
 * D_n has 2n elements: n rotations and n reflections. It is generated by a
 * rotation r (of order n) and a reflection s (of order 2), with the relation
 * `s * r = r^(-1) * s`.
 *
 * @property n The number of vertices of the polygon (must be at least 3).
 * @throws IllegalArgumentException if [n] is less than 3.
 */
class DihedralGroup(val n: Int) : Group<DihedralElement> {
    init {
        require(n >= 3) { "Dihedral group requires n >= 3." }
    }

    override val identity: DihedralElement = DihedralElement(0, false)

    override fun op(a: DihedralElement, b: DihedralElement): DihedralElement {
        return if (!a.reflected) {
            DihedralElement(
                rotation = (a.rotation + if (b.reflected) (n - b.rotation) % n else b.rotation) % n,
                reflected = b.reflected
            ).let {
                if (a.reflected == b.reflected) {
                    DihedralElement((a.rotation + b.rotation) % n, false)
                } else if (!a.reflected && !b.reflected) {
                    DihedralElement((a.rotation + b.rotation) % n, false)
                } else if (!a.reflected && b.reflected) {
                    DihedralElement((a.rotation + b.rotation) % n, true)
                } else {
                    DihedralElement(((a.rotation - b.rotation) % n + n) % n, false)
                }
            }
        } else {
            if (!b.reflected) {
                DihedralElement(((a.rotation - b.rotation) % n + n) % n, true)
            } else {
                DihedralElement(((a.rotation - b.rotation) % n + n) % n, false)
            }
        }
    }

    override fun inverse(a: DihedralElement): DihedralElement {
        return if (!a.reflected) {
            DihedralElement((n - a.rotation) % n, false)
        } else {
            a
        }
    }

    val r: DihedralElement = DihedralElement(1, false)

    val s: DihedralElement = DihedralElement(0, true)

    fun elements(): Set<DihedralElement> {
        val result = mutableSetOf<DihedralElement>()
        for (k in 0 until n) {
            result.add(DihedralElement(k, false))
            result.add(DihedralElement(k, true))
        }
        return result
    }

    fun order(): Int = 2 * n

    fun rotations(): Set<DihedralElement> = (0 until n).map { DihedralElement(it, false) }.toSet()

    fun reflections(): Set<DihedralElement> = (0 until n).map { DihedralElement(it, true) }.toSet()
}
